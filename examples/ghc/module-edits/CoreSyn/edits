
#
# skipping or redefining unfolding info so that it is 'NoUnfolding'
#

# redefine Definition Core.isEvaldUnfolding : Core.Unfolding -> bool
#  := fun x => false.
#redefine Definition Core.isConLikeUnfolding  : Core.Unfolding -> bool
#  := fun x => false.
#redefine Definition Core.hasSomeUnfolding : Core.Unfolding -> bool
#  := fun x => false.



#axiomatize definition Core.maybeUnfoldingTemplate
axiomatize definition Core.unfoldingTemplate

#redefine Definition Core.otherCons : Core.Unfolding -> (list Core.AltCon) :=
#  fun u => nil.

#redefine Definition Core.isValueUnfolding : Core.Unfolding -> bool :=
#  fun x => false.

#redefine Definition Core.isCheapUnfolding  : Core.Unfolding -> bool :=
#  fun x => false.

#redefine Definition Core.isExpandableUnfolding : Core.Unfolding -> bool :=
#  fun x => false.

#redefine Definition Core.expandUnfolding_maybe : Core.Unfolding -> option Core.CoreExpr := fun x => None.

#redefine Definition Core.isCompulsoryUnfolding : Core.Unfolding -> bool :=
#  fun x => false.
#redefine Definition Core.isStableUnfolding : Core.Unfolding -> bool :=
#  fun x => false.
#redefine Definition Core.isBootUnfolding : Core.Unfolding -> bool :=
#  fun u => false.
#redefine Definition Core.isFragileUnfolding : Core.Unfolding -> bool :=
#  fun u => false.
#redefine Definition Core.canUnfold : Core.Unfolding -> bool :=
#  fun x => false.

#
#  These are 'smart' constructors for constructors that no longer exist.
#
skip Core.bootUnfolding
skip Core.mkOtherCon
skip Core.evaldUnfolding

#
# We cannot translate this while skipping all but NoUnfolding because
# the 'BootUnfolding' returns true whereas all others return false
#
skip Core.hasSomeUnfolding


# axiomatize definition Core.evaldUnfolding


#
# Tick-related functions
#

skip Core.mkNoCount
skip Core.mkNoScope

axiomatize definition Core.tickishCounts
axiomatize definition Core.tickishIsCode

skip Core.tickishCanSplit
skip Core.tickishContains

#
# record selector, no place to add default
#
skip Core.uf_tmpl
skip Core.ru_rhs

#
# ordering
#
order Core.Eq___DataCon Core.Eq___AltCon_op_zeze__ Core.Eq___AltCon Core.Ord__AltCon
order Core.Eq___Tickish Core.Ord__Tickish

#
# Termination & mutual recursion edits
#
inline mutual Core.deTagAlt
inline mutual Core.deTagBind

inline mutual Core.deAnnotate
inline mutual Core.deAnnAlt


# Core.collectNAnnBndrs is defined in the midamble
skip Core.collectNAnnBndrs
#
# It needs a default constraint, as well as a termination argument
# ISSUE: unfortunately our termination edits don't work in the presence 
# of a default constraint because the type changes.
#
# set type Core.collectNAnnBndrs : forall {bndr} {annot} `{(GHC.Err.Default annot)}, nat -> (Core.AnnExpr bndr annot -> (list bndr * Core.AnnExpr bndr annot))
# in Core.collectNAnnBndrs termination collect { measure arg_0__ }
#

in Core.collectAnnArgs termination go { measure (size_AnnExpr' (snd arg_0__)) }
obligations Core.collectAnnArgs solve_collectAnnArgsTicks

in Core.collectAnnArgsTicks termination go { measure (size_AnnExpr' (snd arg_0__)) }
obligations Core.collectAnnArgsTicks solve_collectAnnArgsTicks

in Core.collectAnnBndrs     termination collect { measure (size_AnnExpr' (snd arg_1__)) }

#
# The original version of this function uses 'minimum' and an indirect test
# of whether (occs := map nameOccName local_names) is nonempty. 
#
redefine Definition Core.chooseOrphanAnchor (local_names : list Name.Name) : IsOrphan :=
    match  GHC.Base.map Name.nameOccName local_names with
    | cons hd tl => NotOrphan (Data.Foldable.foldr GHC.Base.min hd tl)
    | nil => Mk_IsOrphan
    end.

#
# Skipping unnecessary functions
#

# no type information
skip Core.exprToType
skip Core.applyTypeToArg

# needs GHC.Types.Double & other types ( GHC.Types.Float, GHC.Int.Int64)
skip Core.mkDoubleLitDouble
skip Core.mkFloatLitFloat
skip Core.mkInt64LitInt64

# needs Literal.mkMachInt
skip Core.mkIntLit
skip Core.mkIntLitInt

# needs Literal.mlMachWord64, Literal.mkMachWOrd
skip Core.mkWord64LitWord64
skip Core.mkWordLit
skip Core.mkWordLitWord

#
# Default instances
#
skip Core.Default__Class
skip Core.Default__DataCon
skip Core.Default__IdInfo
skip Core.Default__RnEnv2
skip Core.Default__Var
skip Core.Default__PatSyn
skip Core.Default__CoreRule
skip Core.Default__RuleEnv
